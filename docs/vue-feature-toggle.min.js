(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.vueFeatureToggle = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
  ;(function(root, factory) { // eslint-disable-line no-extra-semi
    var deepDiff = factory(root);
    // eslint-disable-next-line no-undef
    if (typeof define === 'function' && define.amd) {
        // AMD
        define('DeepDiff', function() { // eslint-disable-line no-undef
            return deepDiff;
        });
    } else if (typeof exports === 'object' || typeof navigator === 'object' && navigator.product.match(/ReactNative/i)) {
        // Node.js or ReactNative
        module.exports = deepDiff;
    } else {
        // Browser globals
        var _deepdiff = root.DeepDiff;
        deepDiff.noConflict = function() {
            if (root.DeepDiff === deepDiff) {
                root.DeepDiff = _deepdiff;
            }
            return deepDiff;
        };
        root.DeepDiff = deepDiff;
    }
  }(this, function(root) {
    var validKinds = ['N', 'E', 'A', 'D'];
  
    // nodejs compatible on server side and in the browser.
    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  
    function Diff(kind, path) {
      Object.defineProperty(this, 'kind', {
        value: kind,
        enumerable: true
      });
      if (path && path.length) {
        Object.defineProperty(this, 'path', {
          value: path,
          enumerable: true
        });
      }
    }
  
    function DiffEdit(path, origin, value) {
      DiffEdit.super_.call(this, 'E', path);
      Object.defineProperty(this, 'lhs', {
        value: origin,
        enumerable: true
      });
      Object.defineProperty(this, 'rhs', {
        value: value,
        enumerable: true
      });
    }
    inherits(DiffEdit, Diff);
  
    function DiffNew(path, value) {
      DiffNew.super_.call(this, 'N', path);
      Object.defineProperty(this, 'rhs', {
        value: value,
        enumerable: true
      });
    }
    inherits(DiffNew, Diff);
  
    function DiffDeleted(path, value) {
      DiffDeleted.super_.call(this, 'D', path);
      Object.defineProperty(this, 'lhs', {
        value: value,
        enumerable: true
      });
    }
    inherits(DiffDeleted, Diff);
  
    function DiffArray(path, index, item) {
      DiffArray.super_.call(this, 'A', path);
      Object.defineProperty(this, 'index', {
        value: index,
        enumerable: true
      });
      Object.defineProperty(this, 'item', {
        value: item,
        enumerable: true
      });
    }
    inherits(DiffArray, Diff);
  
    function arrayRemove(arr, from, to) {
      var rest = arr.slice((to || from) + 1 || arr.length);
      arr.length = from < 0 ? arr.length + from : from;
      arr.push.apply(arr, rest);
      return arr;
    }
  
    function realTypeOf(subject) {
      var type = typeof subject;
      if (type !== 'object') {
        return type;
      }
  
      if (subject === Math) {
        return 'math';
      } else if (subject === null) {
        return 'null';
      } else if (Array.isArray(subject)) {
        return 'array';
      } else if (Object.prototype.toString.call(subject) === '[object Date]') {
        return 'date';
      } else if (typeof subject.toString === 'function' && /^\/.*\//.test(subject.toString())) {
        return 'regexp';
      }
      return 'object';
    }
  
    // http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/
    function hashThisString(string) {
      var hash = 0;
      if (string.length === 0) { return hash; }
      for (var i = 0; i < string.length; i++) {
        var char = string.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      return hash;
    }
  
    // Gets a hash of the given object in an array order-independent fashion
    // also object key order independent (easier since they can be alphabetized)
    function getOrderIndependentHash(object) {
      var accum = 0;
      var type = realTypeOf(object);
  
      if (type === 'array') {
        object.forEach(function (item) {
          // Addition is commutative so this is order indep
          accum += getOrderIndependentHash(item);
        });
  
        var arrayString = '[type: array, hash: ' + accum + ']';
        return accum + hashThisString(arrayString);
      }
  
      if (type === 'object') {
        for (var key in object) {
          if (object.hasOwnProperty(key)) {
            var keyValueString = '[ type: object, key: ' + key + ', value hash: ' + getOrderIndependentHash(object[key]) + ']';
            accum += hashThisString(keyValueString);
          }
        }
  
        return accum;
      }
  
      // Non object, non array...should be good?
      var stringToHash = '[ type: ' + type + ' ; value: ' + object + ']';
      return accum + hashThisString(stringToHash);
    }
  
    function deepDiff(lhs, rhs, changes, prefilter, path, key, stack, orderIndependent) {
      changes = changes || [];
      path = path || [];
      stack = stack || [];
      var currentPath = path.slice(0);
      if (typeof key !== 'undefined' && key !== null) {
        if (prefilter) {
          if (typeof (prefilter) === 'function' && prefilter(currentPath, key)) {
            return;
          } else if (typeof (prefilter) === 'object') {
            if (prefilter.prefilter && prefilter.prefilter(currentPath, key)) {
              return;
            }
            if (prefilter.normalize) {
              var alt = prefilter.normalize(currentPath, key, lhs, rhs);
              if (alt) {
                lhs = alt[0];
                rhs = alt[1];
              }
            }
          }
        }
        currentPath.push(key);
      }
  
      // Use string comparison for regexes
      if (realTypeOf(lhs) === 'regexp' && realTypeOf(rhs) === 'regexp') {
        lhs = lhs.toString();
        rhs = rhs.toString();
      }
  
      var ltype = typeof lhs;
      var rtype = typeof rhs;
      var i, j, k, other;
  
      var ldefined = ltype !== 'undefined' ||
        (stack && (stack.length > 0) && stack[stack.length - 1].lhs &&
          Object.getOwnPropertyDescriptor(stack[stack.length - 1].lhs, key));
      var rdefined = rtype !== 'undefined' ||
        (stack && (stack.length > 0) && stack[stack.length - 1].rhs &&
          Object.getOwnPropertyDescriptor(stack[stack.length - 1].rhs, key));
  
      if (!ldefined && rdefined) {
        changes.push(new DiffNew(currentPath, rhs));
      } else if (!rdefined && ldefined) {
        changes.push(new DiffDeleted(currentPath, lhs));
      } else if (realTypeOf(lhs) !== realTypeOf(rhs)) {
        changes.push(new DiffEdit(currentPath, lhs, rhs));
      } else if (realTypeOf(lhs) === 'date' && (lhs - rhs) !== 0) {
        changes.push(new DiffEdit(currentPath, lhs, rhs));
      } else if (ltype === 'object' && lhs !== null && rhs !== null) {
        for (i = stack.length - 1; i > -1; --i) {
          if (stack[i].lhs === lhs) {
            other = true;
            break;
          }
        }
        if (!other) {
          stack.push({ lhs: lhs, rhs: rhs });
          if (Array.isArray(lhs)) {
            // If order doesn't matter, we need to sort our arrays
            if (orderIndependent) {
              lhs.sort(function (a, b) {
                return getOrderIndependentHash(a) - getOrderIndependentHash(b);
              });
  
              rhs.sort(function (a, b) {
                return getOrderIndependentHash(a) - getOrderIndependentHash(b);
              });
            }
            i = rhs.length - 1;
            j = lhs.length - 1;
            while (i > j) {
              changes.push(new DiffArray(currentPath, i, new DiffNew(undefined, rhs[i--])));
            }
            while (j > i) {
              changes.push(new DiffArray(currentPath, j, new DiffDeleted(undefined, lhs[j--])));
            }
            for (; i >= 0; --i) {
              deepDiff(lhs[i], rhs[i], changes, prefilter, currentPath, i, stack, orderIndependent);
            }
          } else {
            var akeys = Object.keys(lhs);
            var pkeys = Object.keys(rhs);
            for (i = 0; i < akeys.length; ++i) {
              k = akeys[i];
              other = pkeys.indexOf(k);
              if (other >= 0) {
                deepDiff(lhs[k], rhs[k], changes, prefilter, currentPath, k, stack, orderIndependent);
                pkeys[other] = null;
              } else {
                deepDiff(lhs[k], undefined, changes, prefilter, currentPath, k, stack, orderIndependent);
              }
            }
            for (i = 0; i < pkeys.length; ++i) {
              k = pkeys[i];
              if (k) {
                deepDiff(undefined, rhs[k], changes, prefilter, currentPath, k, stack, orderIndependent);
              }
            }
          }
          stack.length = stack.length - 1;
        } else if (lhs !== rhs) {
          // lhs is contains a cycle at this element and it differs from rhs
          changes.push(new DiffEdit(currentPath, lhs, rhs));
        }
      } else if (lhs !== rhs) {
        if (!(ltype === 'number' && isNaN(lhs) && isNaN(rhs))) {
          changes.push(new DiffEdit(currentPath, lhs, rhs));
        }
      }
    }
  
    function observableDiff(lhs, rhs, observer, prefilter, orderIndependent) {
      var changes = [];
      deepDiff(lhs, rhs, changes, prefilter, null, null, null, orderIndependent);
      if (observer) {
        for (var i = 0; i < changes.length; ++i) {
          observer(changes[i]);
        }
      }
      return changes;
    }
  
    function orderIndependentDeepDiff(lhs, rhs, changes, prefilter, path, key, stack) {
      return deepDiff(lhs, rhs, changes, prefilter, path, key, stack, true);
    }
  
    function accumulateDiff(lhs, rhs, prefilter, accum) {
      var observer = (accum) ?
        function (difference) {
          if (difference) {
            accum.push(difference);
          }
        } : undefined;
      var changes = observableDiff(lhs, rhs, observer, prefilter);
      return (accum) ? accum : (changes.length) ? changes : undefined;
    }
  
    function accumulateOrderIndependentDiff(lhs, rhs, prefilter, accum) {
      var observer = (accum) ?
        function (difference) {
          if (difference) {
            accum.push(difference);
          }
        } : undefined;
      var changes = observableDiff(lhs, rhs, observer, prefilter, true);
      return (accum) ? accum : (changes.length) ? changes : undefined;
    }
  
    function applyArrayChange(arr, index, change) {
      if (change.path && change.path.length) {
        var it = arr[index],
          i, u = change.path.length - 1;
        for (i = 0; i < u; i++) {
          it = it[change.path[i]];
        }
        switch (change.kind) {
          case 'A':
            applyArrayChange(it[change.path[i]], change.index, change.item);
            break;
          case 'D':
            delete it[change.path[i]];
            break;
          case 'E':
          case 'N':
            it[change.path[i]] = change.rhs;
            break;
        }
      } else {
        switch (change.kind) {
          case 'A':
            applyArrayChange(arr[index], change.index, change.item);
            break;
          case 'D':
            arr = arrayRemove(arr, index);
            break;
          case 'E':
          case 'N':
            arr[index] = change.rhs;
            break;
        }
      }
      return arr;
    }
  
    function applyChange(target, source, change) {
      if (typeof change === 'undefined' && source && ~validKinds.indexOf(source.kind)) {
        change = source;
      }
      if (target && change && change.kind) {
        var it = target,
          i = -1,
          last = change.path ? change.path.length - 1 : 0;
        while (++i < last) {
          if (typeof it[change.path[i]] === 'undefined') {
            it[change.path[i]] = (typeof change.path[i + 1] !== 'undefined' && typeof change.path[i + 1] === 'number') ? [] : {};
          }
          it = it[change.path[i]];
        }
        switch (change.kind) {
          case 'A':
            if (change.path && typeof it[change.path[i]] === 'undefined') {
              it[change.path[i]] = [];
            }
            applyArrayChange(change.path ? it[change.path[i]] : it, change.index, change.item);
            break;
          case 'D':
            delete it[change.path[i]];
            break;
          case 'E':
          case 'N':
            it[change.path[i]] = change.rhs;
            break;
        }
      }
    }
  
    function revertArrayChange(arr, index, change) {
      if (change.path && change.path.length) {
        // the structure of the object at the index has changed...
        var it = arr[index],
          i, u = change.path.length - 1;
        for (i = 0; i < u; i++) {
          it = it[change.path[i]];
        }
        switch (change.kind) {
          case 'A':
            revertArrayChange(it[change.path[i]], change.index, change.item);
            break;
          case 'D':
            it[change.path[i]] = change.lhs;
            break;
          case 'E':
            it[change.path[i]] = change.lhs;
            break;
          case 'N':
            delete it[change.path[i]];
            break;
        }
      } else {
        // the array item is different...
        switch (change.kind) {
          case 'A':
            revertArrayChange(arr[index], change.index, change.item);
            break;
          case 'D':
            arr[index] = change.lhs;
            break;
          case 'E':
            arr[index] = change.lhs;
            break;
          case 'N':
            arr = arrayRemove(arr, index);
            break;
        }
      }
      return arr;
    }
  
    function revertChange(target, source, change) {
      if (target && source && change && change.kind) {
        var it = target,
          i, u;
        u = change.path.length - 1;
        for (i = 0; i < u; i++) {
          if (typeof it[change.path[i]] === 'undefined') {
            it[change.path[i]] = {};
          }
          it = it[change.path[i]];
        }
        switch (change.kind) {
          case 'A':
            // Array was modified...
            // it will be an array...
            revertArrayChange(it[change.path[i]], change.index, change.item);
            break;
          case 'D':
            // Item was deleted...
            it[change.path[i]] = change.lhs;
            break;
          case 'E':
            // Item was edited...
            it[change.path[i]] = change.lhs;
            break;
          case 'N':
            // Item is new...
            delete it[change.path[i]];
            break;
        }
      }
    }
  
    function applyDiff(target, source, filter) {
      if (target && source) {
        var onChange = function (change) {
          if (!filter || filter(target, source, change)) {
            applyChange(target, source, change);
          }
        };
        observableDiff(target, source, onChange);
      }
    }
  
    Object.defineProperties(accumulateDiff, {
  
      diff: {
        value: accumulateDiff,
        enumerable: true
      },
      orderIndependentDiff: {
        value: accumulateOrderIndependentDiff,
        enumerable: true
      },
      observableDiff: {
        value: observableDiff,
        enumerable: true
      },
      orderIndependentObservableDiff: {
        value: orderIndependentDeepDiff,
        enumerable: true
      },
      orderIndepHash: {
        value: getOrderIndependentHash,
        enumerable: true
      },
      applyDiff: {
        value: applyDiff,
        enumerable: true
      },
      applyChange: {
        value: applyChange,
        enumerable: true
      },
      revertChange: {
        value: revertChange,
        enumerable: true
      },
      isConflict: {
        value: function () {
          return typeof $conflict !== 'undefined';
        },
        enumerable: true
      }
    });
  
    // hackish...
    accumulateDiff.DeepDiff = accumulateDiff;
    // ...but works with:
    // import DeepDiff from 'deep-diff'
    // import { DeepDiff } from 'deep-diff'
    // const DeepDiff = require('deep-diff');
    // const { DeepDiff } = require('deep-diff');
  
    if (root) {
      root.DeepDiff = accumulateDiff;
    }
  
    return accumulateDiff;
  }));
  
  },{}],2:[function(require,module,exports){
  'use strict';
  
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
  
  var parseToFn = function parseToFn(fnOrBool) {
      if (typeof fnOrBool == 'boolean') return function () {
          return fnOrBool;
      };
  
      return fnOrBool;
  };
  
  function initVisibilities() {
      var visibilities = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  
      var returnVisibilities = {};
      Object.keys(visibilities).forEach(function (key) {
          if (key.startsWith('_')) return;
          returnVisibilities[key] = parseToFn(visibilities[key]);
      });
      return returnVisibilities;
  }
  
  function featuretoggleapi() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  
  
      var globals = {
          datas: {},
          listeners: {},
          visibilities: initVisibilities(config),
          showLogs: false,
          usedPlugins: []
      };
  
      function init(api) {
          if (config._plugins) {
              if (!Array.isArray(config._plugins)) throw new Error('featuretoggleapi()-constructor: config.plugins must be an array.');
  
              config._plugins.forEach(function (plugin) {
                  if (typeof plugin !== 'function') throw new Error('featuretoggleapi()-constructor: config.plugins needs functions as entries, not ' + (typeof plugin === 'undefined' ? 'undefined' : _typeof(plugin)) + '.');
  
                  _addPlugin(plugin, api);
              });
          }
  
          triggerEvent('init');
      }
  
      function _addPlugin(plugin, api) {
          plugin(api);
      }
  
      function triggerEvent(eventtype, param) {
          (globals.listeners[eventtype] || []).forEach(function (listener) {
              listener(param);
          });
      }
  
      var log = function log(message) {
          if (!globals.showLogs) return;
  
          //Nur Browser können Syntaxhighlighting die anderen geben die Nachricht einfach aus und schneiden
          //die styletags raus
          if (typeof window === 'undefined') {
              var loggedMessage = message.replace(/<b>/g, "");
              console.log(loggedMessage);
              return;
          }
  
          var hasBoldTag = message.indexOf('<b>') != -1;
          var hasVisibleKeyword = message.indexOf('visible') != -1;
          var hasHiddenKeyword = message.indexOf('hidden') != -1;
  
          var _message = message.replace('visible', '%cvisible');
          _message = _message.replace('hidden', '%chidden');
  
          if (hasVisibleKeyword) console.log(_message, "color:green;font-weight:bold;");else if (hasHiddenKeyword) console.log(_message, "color:red;font-weight:bold;");else if (hasBoldTag) {
              _message = _message.replace('<b>', '%c');
              var parts = [_message, 'font-weight:bold;'];
              console.log.apply(null, parts);
          } else console.log(message);
      };
  
      var logAndReturn = function logAndReturn(returnValue, message) {
          log(message);
          log('');
          return returnValue;
      };
  
      var getVisibility = function getVisibility(visibilityFn, functionname, name, variant, data) {
          if (visibilityFn == null) return undefined;
  
          var calculatedVisibility = visibilityFn({ name: name, variant: variant, data: data });
  
          if (typeof calculatedVisibility == 'boolean') {
              return calculatedVisibility;
          }
  
          return logAndReturn(false, 'The ' + functionname + ' returns ' + calculatedVisibility + '. => Please return true or false. This result (and all non-boolean results) will return false.');
      };
  
      function getKey(name, variant) {
          var _name = name.toLowerCase();
          if (typeof variant == 'string') {
              _name += "#" + variant.toLowerCase();
          }
  
          return _name;
      }
      function parseKey(key) {
          var parts = key.split('#');
          return {
              name: parts[0],
              variant: parts.length > 1 ? parts[1] : undefined,
              data: globals.datas[key]
          };
      }
  
      /*
          the following calls are possible:
          visibility(name,result);
          visibility(name,variant,result);
          visibility(name,variant,data,result);
      
          =>
          param1: name
          param2: result || variant
          param3: result || data
          param4: result
      */
      function visibilityFnParams(param1, param2, param3, param4) {
          //name must always be set
          if (param1 == undefined) throw new Error('feature.visibility(): 1st parameter name must be defined');
  
          if (arguments.length == 1) throw new Error('feature.visibility(): 2nd parameter name must be a boolean or function, but is empty');
  
          var name = param1,
              variant = null,
              data = null,
              result = null;
          if (param3 == undefined && param4 == undefined) {
              result = param2;
          } else if (param4 == undefined) {
              variant = param2;
              result = param3;
          } else {
              variant = param2;
              data = param3;
              result = param4;
          }
  
          return {
              name: name,
              variant: variant,
              data: data,
              result: result
          };
      }
  
      function getEvent(name, variant, data, result) {
  
          var event = void 0;
  
          event = { name: name, variant: variant, data: data };
  
          event.key = getKey(event.name, event.variant);
  
          if (result == null) return event;
  
          event.visibilityFunction = parseToFn(result);
          event.result = event.visibilityFunction({
              name: event.name,
              variant: event.variant,
              data: event.data || {},
              _internalCall: true,
              description: 'When attaching a function, the result must be calculated internally. You can filter this out with the _internalCall:true -Flag.'
          });
          return event;
      }
  
      function isVisible(name, variant, data) {
          var visibilities = globals.visibilities;
  
          log('\nCheck Visibility of <b>Feature "' + name + '", variant "' + (variant == undefined ? '' : variant) + '"' + (data ? " with data " + JSON.stringify(data) : "") + '.');
          if (name == undefined) throw new Error('The attribute "name" is required for tag <feature></feature>. Example: <feature name="aname"></feature>');
  
          var requiredFn = visibilities['_required'];
          var requiredFnExists = visibilities['_required'] != null;
          var requiredFnResult = getVisibility(requiredFn, 'requiredVisibility', name, variant, data);
  
          var visibilityFnKey = getKey(name, variant);
          var visibilityFn = visibilities[visibilityFnKey];
          var visibilityFnExists = visibilities[visibilityFnKey] != null;
          var visibilityFnResult = getVisibility(visibilityFn, 'visibility function', name, variant, data);
  
          var variantExists = variant != null;
          var visibilityOnlyNameFnKey = getKey(name, null);
          var visibilityOnlyNameFn = visibilities[visibilityOnlyNameFnKey];
          var visibilityOnlyNameFnResult = getVisibility(visibilityOnlyNameFn, 'visibility function (only name)', name, variant, data);
  
          var defaultFn = visibilities['_default'];
          var defaultFnExists = visibilities['_default'] != null;
          var defaultFnResult = getVisibility(defaultFn, 'defaultVisibility', name, variant, data);
  
          if (!requiredFnExists) log("No requiredVisibility rule specified for this feature.");else if (requiredFnExists && requiredFnResult === true) log("The requiredVisibility rule returns true. This feature will be shown when no other rule rejects it.");else if (requiredFnExists && requiredFnResult === false) return logAndReturn(false, "The requiredVisibility rule returns false. This feature will be hidden.");
  
          if (visibilityFnExists) return logAndReturn(visibilityFnResult, 'The visibility rule returns ' + visibilityFnResult + '. This feature will be ' + (visibilityFnResult ? 'visible' : 'hidden') + '.');
          log('No visibility rule found matching name and variant.');
  
          if (variantExists && typeof visibilityOnlyNameFnResult == 'boolean') return logAndReturn(visibilityOnlyNameFnResult, 'Found a visibility rule for name ' + name + ' without variants. The rule returns ' + visibilityOnlyNameFnResult + '. => This feature will be ' + (visibilityOnlyNameFnResult ? 'visible' : 'hidden') + '.');else if (variantExists) log('No rules found for name ' + name + ' without variants.');
  
          if (defaultFnExists) return logAndReturn(defaultFnResult, 'Found a defaultVisibility rule. The rule returns ' + defaultFnResult + '. => This feature will be ' + (defaultFnResult ? 'visible' : 'hidden') + '.');
          log('No default rule found.');
  
          if (requiredFnExists) return logAndReturn(true, 'Only the requiredVisibility rule was found. This returned true. => This feature will be visible.');
  
          return logAndReturn(false, 'No rules were found. This feature will be hidden.');
      }
  
      var api = {
          name: 'feature-toggle-api',
          setData: function setData(nameParam, variantOrDataParam, dataParam) {
              if (nameParam == undefined) throw new Error('setData(): The name must of the feature must be defined, but ist undefined');
  
              var variant = dataParam != undefined ? variantOrDataParam : undefined;
              var data = dataParam || variantOrDataParam;
  
              var event = getEvent(nameParam, variant, data);
  
              globals.datas[event.key] = event.data;
  
              triggerEvent('visibilityrule', event);
          },
          on: function on(eventtype, fn, config) {
              globals.listeners[eventtype] = globals.listeners[eventtype] || [];
              globals.listeners[eventtype].push(fn);
  
              triggerEvent('registerEvent', {
                  type: eventtype
              });
              if (config != undefined && config.ignorePreviousRules) return;
  
              Object.keys(globals.visibilities).forEach(function (key) {
                  var event = parseKey(key, globals);
                  var rule = globals.visibilities[key];
                  event.result = rule(event);
                  fn(event);
              });
          },
          trigger: triggerEvent,
          showLogs: function showLogs(_showLogs) {
              globals.showLogs = _showLogs == undefined ? true : _showLogs;
          },
          isVisible: isVisible,
          /*
              the following function calls are possible:
              visibility(name,result);
              visibility(name,variant,result);
              visibility(name,variant,data,result);
          */
          visibility: function visibility(param1, param2, param3, param4) {
              var params = visibilityFnParams(param1, param2, param3, param4);
              var event = getEvent(params.name, params.variant, params.data, params.result);
  
              globals.visibilities[event.key] = event.visibilityFunction;
              globals.datas[event.key] = event.data;
              triggerEvent('visibilityrule', event);
          },
          requiredVisibility: function requiredVisibility(fn) {
              if (typeof fn != "function") throw new Error('feature.requiredVisibility(): 1st parameter must be a function, but is ' + (typeof fn === 'undefined' ? 'undefined' : _typeof(fn)));
  
              globals.visibilities['_required'] = parseToFn(fn);
          },
          defaultVisibility: function defaultVisibility(fn) {
              if (typeof fn != "function") throw new Error('feature.defaultVisibility(): 1st parameter must be a function, but is ' + (typeof fn === 'undefined' ? 'undefined' : _typeof(fn)));
  
              globals.visibilities['_default'] = parseToFn(fn);
          },
          addPlugin: function addPlugin(plugin) {
              if (globals.usedPlugins.includes(plugin)) return;
  
              _addPlugin(plugin, api);
              globals.usedPlugins.push(plugin);
          }
      };
      init(api);
      return api;
  }
  
  module.exports = featuretoggleapi;
  },{}],3:[function(require,module,exports){
  ;(function(){
  "use strict";
  
  var featureToggleApi = require("feature-toggle-api");
  var deepDiff = require('deep-diff');

  var api = new featureToggleApi();
  
  function vuePlugin(api) {
    Object.assign(api, {
      props: {
        name: {
          type: String
        },
        variant: {
          type: String
        },
        data: {
          type: [Object, String]
        },
        tag: {
          type: String,
          default: "div"
        }
      },
      name: "feature",
      data: function data() {
        return {
          isVisible: api.isVisible(this.name, this.variant, this.data)
        };
      },
  
      render: function render(createElement) {
        if (this.isVisible) {
          return createElement(this.tag, {
            "feature-name": this.name,
            "feature-variant": this.variant
          }, this.$slots.default);
        }
      },
      mounted: function mounted() {
        this.init();
      },
      ready: function ready() {
        this.init();
      },
      methods: {
        _isVisible: function _isVisible(name, variant, data) {
          return api.isVisible(name, variant, data);
        },
        init: function init() {
          var self = this;
          api.on("visibilityrule", function (e) {
              if((self.name || "") == (e.name || "") && (self.variant || "") == (e.variant || "") && deepDiff(self.data || "",e.data || "") == undefined)
                self.isVisible = api.isVisible(e.name, e.variant, e.data);
          });
        }
      }
    });
  }
  
  api.addPlugin(vuePlugin);
  module.exports = api;
  })()
  if (module.exports.__esModule) module.exports = module.exports.default
  var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
  __vue__options__._scopeId = "data-v-32d0d8b2"
  
  },{"deep-diff":1,"feature-toggle-api":2}],4:[function(require,module,exports){
  'use strict';
  
  var _Feature = require('./Feature.vue');
  
  var _Feature2 = _interopRequireDefault(_Feature);
  
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  
  module.exports = _Feature2.default;
  
  },{"./Feature.vue":3}]},{},[3,4])(4)
  });