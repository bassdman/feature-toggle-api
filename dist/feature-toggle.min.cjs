"use strict";const e={renderedTag:"div",featureTagName:"feature",tagAttributeName:"tag",nameAttributeName:"name",variantAttributeName:"variant",dataAttributeName:"data",displayAttributeName:"display",defaultDisplay:"block"};function t(e){return"boolean"==typeof e?function(){return e}:e}function i(e,t){var i=e.toLowerCase();return t&&"string"==typeof t&&(i+="#"+t.toLowerCase()),i}function n(e={}){const n={};return Object.keys(e).forEach((r=>{r.startsWith("_")||r.startsWith("$")||(n[i(r)]=t(e[r]))})),n}exports.htmlPlugin=function(t={}){function i(e,i){const n=e.getAttribute(t.tagAttributeName)||t.renderedTag,r=Array.from(e.attributes);let l="";r.forEach((e=>{l+=` ${e.nodeName}="${e.nodeValue.replace(/"/g,"&quot;")}"`}));const a=i?e.getAttribute(t.displayAttributeName)||t.defaultDisplay:"none";e.outerHTML=`<${n}  style="display:${a}" _feature="true" ${l}>${e.innerHTML}</${n}>`}return t=Object.assign({},e,t),function(e){return window.document.querySelectorAll(t.featureTagName).forEach((e=>{i(e,!1)})),e.on("visibilityrule",(function(n){var r=`[_feature][${t.nameAttributeName}="${n.name}"]`;n.variant&&(r+=`[${t.variantAttributeName}="${n.variant}"]`),document.querySelectorAll(r).forEach((r=>{const l=function(e){try{return JSON.parse(e)}catch(t){return isNaN(parseFloat(e))?e:parseFloat(e)}}(r.getAttribute(t.dataAttributeName));i(r,e.isVisible(n.name,n.variant,l))}))})),{name:"htmlplugin"}}},exports.urlPlugin=function(e={}){let t;return t=e.useMockedWindow?{isMocked:!0,decodeURIComponent:function(e){return e}}:window,e=Object.assign({},{url:t.isMocked?"":t.location.href,prefix:""},e),function(i){i.url=e.url;const n=function(e,t){var i={};if(!e)return[];var n=e.split("?");return n.length<2?[]:(n[1].split("&").forEach((function(e){var n=e.split("=");n[0]=t.decodeURIComponent(n[0]),n[1]="true"===t.decodeURIComponent(n[1]),i[n[0]]="undefined"===n[1]||n[1]})),i)}(e.url,t),r=e.prefix;return Object.keys(n).forEach((e=>{if(!e.startsWith(r))return;const t=e.replace(r,"");i.visibility(t,n[e])})),{name:"urlplugin"}}},exports.useFeatureToggle=function(e={}){const r={datas:{},listeners:{},visibilities:n(e),showLogs:!1,usedPlugins:[]};function l(e,t){(r.listeners[e]||[]).forEach((e=>{e(t)}))}const a=function(e){if(r.showLogs)if("undefined"!=typeof window){var t=-1!=e.indexOf("<b>"),i=-1!=e.indexOf("visible"),n=-1!=e.indexOf("hidden"),l=e.replace("visible","%cvisible");if(l=l.replace("hidden","%chidden"),i)console.log(l,"color:green;font-weight:bold;");else if(n)console.log(l,"color:red;font-weight:bold;");else if(t){var a=[l=l.replace("<b>","%c"),"font-weight:bold;"];console.log.apply(null,a)}else console.log(e)}else{const t=e.replace(/<b>/g,"");console.log(t)}},u=function(e,t){return a(t),a(""),e},s=function(e,t,i,n,r){if(null!=e){var l=e({name:i,variant:n,data:r});return"boolean"==typeof l?l:u(!1,`The ${t} returns ${l}. => Please return true or false. This result (and all non-boolean results) will return false.`)}};function o(e,n,r,l){let a;return a={name:e,variant:n,data:r},a.key=i(a.name,a.variant),null==l||(a.visibilityFunction=t(l),a.result=a.visibilityFunction({name:a.name,variant:a.variant,data:a.data||{},_internalCall:!0,description:"When attaching a function, the result must be calculated internally. You can filter this out with the _internalCall:true -Flag."})),a}function f(e,t,n){const l=r.visibilities;if(a(`\nCheck Visibility of <b>Feature "${e}", variant "${null==t?"":t}"${n?" with data "+JSON.stringify(n):""}.`),null==e)throw new Error('The attribute "name" is required for tag <feature></feature>. Example: <feature name="aname"></feature>');var o=l._required,f=null!=l._required,d=s(o,"requiredVisibility",e,t,n),c=i(e,t),b=l[c],g=null!=l[c],h=s(b,"visibility function",e,t,n),v=null!=t,m=l[i(e,null)],p=s(m,"visibility function (only name)",e,t,n),y=l._default,w=null!=l._default,T=s(y,"defaultVisibility",e,t,n);if(f){if(f&&!0===d)a("The requiredVisibility rule returns true. This feature will be shown when no other rule rejects it.");else if(f&&!1===d)return u(!1,"The requiredVisibility rule returns false. This feature will be hidden.")}else a("No requiredVisibility rule specified for this feature.");return g?u(h,`The visibility rule returns ${h}. This feature will be ${h?"visible":"hidden"}.`):(a("No visibility rule found matching name and variant."),v&&"boolean"==typeof p?u(p,`Found a visibility rule for name ${e} without variants. The rule returns ${p}. => This feature will be ${p?"visible":"hidden"}.`):(v&&a(`No rules found for name ${e} without variants.`),w?u(T,`Found a defaultVisibility rule. The rule returns ${T}. => This feature will be ${T?"visible":"hidden"}.`):(a("No default rule found."),f?u(!0,"Only the requiredVisibility rule was found. This returned true. => This feature will be visible."):u(!1,"No rules were found. This feature will be hidden."))))}const d={name:"feature-toggle-api",setData:function(e,t,i){if(null==e)throw new Error("setData(): The name must of the feature must be defined, but ist undefined");const n=o(e,null!=i?t:void 0,i||t);r.datas[n.key]=n.data,l("visibilityrule",n)},on:function(e,t,i){r.listeners[e]=r.listeners[e]||[],r.listeners[e].push(t),l("registerEvent",{type:e}),null!=i&&i.ignorePreviousRules||Object.keys(r.visibilities).forEach((e=>{const i=function(e){const t=e.split("#");return{name:t[0],variant:t.length>1?t[1]:void 0,data:r.datas[e]}}(e),n=r.visibilities[e];i.result=n(i),t(i)}))},trigger:l,showLogs:function(e){r.showLogs=null==e||e},isVisible:(e,t,i)=>(console.log("featureToggle.isVisible is deprecated. use featureToggle.isActive instead. This function will be removed in one of the next major versions."),f(e,t,i)),isActive:f,setFlag(e,t,i,n){const a=function(e,t,i,n){if(null==e)throw new Error("feature.visibility(): 1st parameter name must be defined");if(1==arguments.length)throw new Error("feature.visibility(): 2nd parameter name must be a boolean or function, but is empty");let r=null,l=null,a=null;return null==i&&null==n?a=t:null==n?(r=t,a=i):(r=t,l=i,a=n),{name:e,variant:r,data:l,result:a}}(e,t,i,n),u=o(a.name,a.variant,a.data,a.result);r.visibilities[u.key]=u.visibilityFunction,r.datas[u.key]=u.data,l("visibilityrule",u)},visibility:function(e,t,i,n){console.log("featureToggle.visibility is deprecated. use featureToggle.setVisibility instead. This function will be removed in one of the next major versions."),d.setFlag(e,t,i,n)},requiredVisibility:function(e){console.log("featureToggle.requiredVisibility is deprecated. use featureToggle.setRequiredFlag instead. This function will be removed in one of the next major versions."),d.setRequiredFlag(e)},defaultVisibility:function(e){console.log("featureToggle.requiredVisibility is deprecated. use featureToggle.setRequiredFlag instead. This function will be removed in one of the next major versions."),d.setDefaultFlag(e)},setRequiredFlag(e){if("function"!=typeof e)throw new Error("feature.setRequiredFlag(): 1st parameter must be a function, but is "+typeof e);r.visibilities._required=t(e)},setDefaultFlag(e){if("function"!=typeof e)throw new Error("feature.defaultVisibility(): 1st parameter must be a function, but is "+typeof e);r.visibilities._default=t(e)},addPlugin:function(e){r.usedPlugins.includes(e)||(e(d),r.usedPlugins.push(e))}};return function(t){const i=[...e.$plugins||[],...e._plugins||[]];e._plugins&&console.log("useFeatureToggle({_plugins:[]}): Key _plugins is deprecated. Use $plugins instead. This attribute will be removed in one of the next major versions."),i.length&&i.forEach((e=>{if("function"!=typeof e)throw new Error("featuretoggleapi()-constructor: config.plugins needs functions as entries, not "+typeof e+".");e(t)})),l("init")}(d),d};
//# sourceMappingURL=feature-toggle.min.cjs.map
